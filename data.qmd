# Data

## Technical Description

The dataset utilized for this project is sourced from [cheese.com](https://cheese.com/) as part of the [TidyTuesday](https://github.com/rfordatascience/tidytuesday) initiative for the week of June 4, 2024. It comprises information on 248 different cheeses from around the world. The primary focus is to explore the relationship between fat content and various characteristics of cheeses, such as type, texture, flavor, and aroma.

### Data Source:

The dataset used for this project is sourced from [cheese.com](https://cheese.com/), curated as part of the [TidyTuesday project for June 4, 2024](https://github.com/rfordatascience/tidytuesday/blob/master/data/2024/2024-06-04/readme.md). 

TidyTuesday is a weekly data project aimed at helping the R community practice their data wrangling, visualization, and analysis skills. The cheese dataset contains information on various types of cheeses worldwide, including attributes such as fat content, texture, flavor, aroma, and production details. The dataset encourages exploration of relationships between these characteristics.

### Variables Included:

- **cheese**: Name of the cheese.
- **url**: URL to the cheese's description on cheese.com.
- **milk**: Type of milk used (e.g., cow, goat, sheep).
- **country**: Country or countries of origin.
- **region**: Specific region within the country of origin.
- **family**: Family classification of the cheese.
- **type**: Broad type categories describing the cheese.
- **fat_content**: Fat content percentage.
- **calcium_content**: Calcium content (when available).
- **texture**: Description of the cheese's texture.
- **rind**: Type of rind used.
- **color**: Color description.
- **flavor**: Characteristics of taste.
- **aroma**: Characteristics of smell.
- **vegetarian**: Indicates if the cheese is vegetarian.
- **vegan**: Indicates if the cheese is vegan.
- **synonyms**: Alternative names for the cheese.
- **alt_spellings**: Alternative spellings of the cheese's name.
- **producers**: Known producers of the cheese.

This dataset provides a rich foundation for exploratory data analysis, enabling the investigation of various attributes and their interrelationships within the cheese domain.

### Installing packages

```{r,message=FALSE,warning=FALSE}
# Install necessary packages
required_packages <- c("tidyverse", "tidytuesdayR", "naniar", "here", "fs", "rvest", "polite", "glue", "kableExtra")
installed_packages <- rownames(installed.packages())

# Load libraries
library(tidyverse)
library(tidytuesdayR)
library(naniar) # For missing value analysis
library(here)
library(fs)
library(rvest)
library(polite)
library(glue)
library(kableExtra) # For enhanced table styling
```

### Loading and Cleaning the Data

```{r,message=FALSE,warning=FALSE}
tuesdata <- tidytuesdayR::tt_load('2024-06-04')

# Extract the cheeses dataset
cheeses <- tuesdata$cheeses

# Save the cheeses dataset to a CSV file
write.csv(cheeses, "cheeses_dataset.csv", row.names = FALSE)

# Confirm the file has been saved
cat("Dataset saved as 'cheeses_dataset.csv'")

# Display the first few rows
head(cheeses)
```

### Cleaning and transforming the data

```{r}
# Cleaning and transforming the data

cheeses <- cheeses %>%
  mutate(
    fat_content = str_extract(fat_content, "\\d+\\.*\\d*") %>% as.numeric(),
    calcium_content = str_extract(calcium_content, "\\d+\\.*\\d*") %>% as.numeric(),
    vegetarian = case_when(
      vegetarian == "yes" ~ TRUE,
      vegetarian == "no" ~ FALSE,
      TRUE ~ NA
    ),
    vegan = case_when(
      vegan == "yes" ~ TRUE,
      vegan == "no" ~ FALSE,
      TRUE ~ NA
    )
  )

# Check the transformation
glimpse(cheeses)
```

The code is used to clean and adjust the cheeses dataset by converting the fat_content and calcium_content columns into numeric values, extracting only the relevant digits. It also changes the vegetarian and vegan columns from “yes”/“no” responses to Boolean values (TRUE/FALSE), handling any other responses as NA. After these changes, the glimpse() function is used to check the updated dataset.

## Missing Value Analysis

Understanding the presence and patterns of missing data is crucial for ensuring the integrity of the analysis. Below is a summary and visualization of missing values in the dataset.

### Visualization of Missing Data

The following plot illustrates the pattern of missing values across different variables, providing a visual overview of data completeness.

```{r}
# Plot missing data with improvements
vis_miss(cheeses) + 
  theme_minimal() +
  labs(title = "Missing Data Pattern in Cheeses Dataset",
       x = "Variables",
       y = "Observations") +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),  # Rotate labels vertically
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5)  # Center and bold title
  )
```

This visualization provides an overview of the missing data patterns in the Cheeses dataset. Each variable is displayed along the x-axis, and the presence or absence of data for each observation is represented in the y-axis.
	•	The black regions represent missing values, while the gray regions indicate available data.
	•	Variables like vegetarian, vegan, and alt_spellings show significant amounts of missing data, with up to 100% missing for some variables.
	•	On the other hand, variables like cheese and url have no missing values, ensuring reliability in these fields for analysis.

This visualization highlights areas where imputation or exclusion strategies need to be applied to handle missing data effectively before proceeding with further analysis.

### Overall Missing Data Pie Chart

To provide an additional perspective on the missing data, here’s a pie chart that visualizes the overall proportion of missing versus present data in the dataset.

```{r}
# Calculate total missing and present values
total_missing <- sum(is.na(cheeses))
total_present <- sum(!is.na(cheeses))

# Create a data frame for the pie chart
missing_data_pie <- data.frame(
  Status = c("Missing", "Present"),
  Count = c(total_missing, total_present)
)

# Calculate percentages
missing_data_pie <- missing_data_pie %>%
  mutate(Percentage = round(Count / sum(Count) * 100, 1))

# Plot the pie chart with percentages
ggplot(missing_data_pie, aes(x = "", y = Count, fill = Status)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar(theta = "y") +
  geom_text(aes(label = paste0(Percentage, "%")), 
            position = position_stack(vjust = 0.5), size = 5) +
  labs(title = "Overall Missing vs Present Data") +
  theme_void() +
  theme(
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
    legend.title = element_blank(),
    legend.position = "right"
  )
```

The pie chart above provides a clear summary of the overall missing versus present data in the dataset. This visualization complements the heatmap by offering a high-level view of data completeness, aiding in quickly assessing the extent of missing data.

### Handling Missing Values

To address the missing data, we employed the following strategies:

1. **Removal of Incomplete Cases:** Rows with missing `fat_content` were excluded to ensure data integrity.

2. **Imputation:** Missing values in `calcium_content` were imputed using the median value, preserving the central tendency of the data.

These steps help mitigate the impact of missing data on our analysis, ensuring more reliable results.

```{r}
# Summary of missing values before cleaning
missing_summary_before <- cheeses %>%
  summarise_all(~ sum(is.na(.))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Missing_Count") %>%
  arrange(desc(Missing_Count))

# Removing rows with missing fat_content
cheeses_clean <- cheeses %>%
  filter(!is.na(fat_content))

# Imputing missing calcium_content with the median value
cheeses_clean <- cheeses_clean %>%
  mutate(calcium_content = if_else(is.na(calcium_content),
                                   median(calcium_content, na.rm = TRUE),
                                   calcium_content))

# Summary of missing values after cleaning
missing_summary_after <- cheeses_clean %>%
  summarise_all(~ sum(is.na(.))) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Missing_Count") %>%
  arrange(desc(Missing_Count))

# Display the summary tables before and after cleaning
knitr::kable(missing_summary_before, caption = "Missing Values Before Cleaning") %>%
  kableExtra::kable_styling(full_width = FALSE, position = "left") %>%
  kableExtra::add_header_above(c(" " = 1, "Missing Values" = 1))

knitr::kable(missing_summary_after, caption = "Missing Values After Cleaning") %>%
  kableExtra::kable_styling(full_width = FALSE, position = "left") %>%
  kableExtra::add_header_above(c(" " = 1, "Missing Values" = 1))
```

The code provided effectively handles missing values in the dataset by first summarizing the missing data before any cleaning is done. It identifies the columns with the most missing values, such as vegetarian and vegan, which initially had 1187 missing entries. Next, the code removes rows with missing fat_content values and imputes missing calcium_content values with the median value, ensuring the dataset remains complete without losing important data. After cleaning, the missing values for key variables are significantly reduced, demonstrating the success of the cleaning process. This approach makes the dataset more reliable for analysis, ensuring that missing data doesn’t skew the results or lead to biased conclusions.


```{r}
cheese_country_counts <- cheeses_clean %>%
  count(country, sort = TRUE) %>%
  head(15)

ggplot(cheese_country_counts, aes(x = reorder(country, n), y = n)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "Top 15 Countries Producing Cheese",
       x = "Country",
       y = "Number of Cheeses") +
  theme_minimal()
```
```{r}
top_countries <- cheese_country_counts$country

ggplot(cheeses_clean %>% filter(country %in% top_countries), 
       aes(x = country, y = fat_content, fill = country)) +
  geom_boxplot() +
  coord_flip() +
  labs(title = "Fat Content Distribution Across Top Cheese-Producing Countries",
       x = "Country",
       y = "Fat Content (%)") +
  theme_minimal()
```

```{r}
family_counts <- cheeses_clean %>%
  count(family, sort = TRUE) %>%
  filter(!is.na(family))

ggplot(family_counts, aes(x = reorder(family, n), y = n, fill = family)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Cheese Family Diversity",
       x = "Family",
       y = "Number of Cheeses") +
  theme_minimal()
```

```{r}
ggplot(cheeses_clean, aes(x = fat_content)) +
  geom_histogram(binwidth = 5, fill = "steelblue", color = "white", alpha = 0.8) +
  labs(title = "Distribution of Fat Content",
       x = "Fat Content (%)",
       y = "Count") +
  theme_minimal()
```





```{r}
ggplot(cheeses_clean, aes(x = type, y = fat_content, fill = type)) +
  geom_boxplot(outlier.color = "red", alpha = 0.7) +
  coord_flip() +
  labs(title = "Fat Content by Cheese Type",
       x = "Cheese Type",
       y = "Fat Content (%)") +
  theme_minimal() +
  theme(legend.position = "none")
```

```{r}
library(tidytext)
library(wordcloud2)

texture_words <- cheeses_clean %>%
  filter(!is.na(texture)) %>%
  unnest_tokens(word, texture) %>%
  count(word, sort = TRUE)

wordcloud2(texture_words, size = 0.7)
```
```{r}
library(treemapify)

cheese_diversity <- cheeses_clean %>%
  count(country, family, sort = TRUE)

ggplot(cheese_diversity, aes(area = n, fill = family, label = country)) +
  geom_treemap() +
  geom_treemap_text(color = "white", place = "center", grow = TRUE) +
  labs(title = "Cheese Production Diversity by Country",
       fill = "Family") +
  theme_minimal()
```

```{r}
library(plotly)

plot_ly(cheeses_clean, x = ~fat_content, type = "histogram") %>%
  layout(title = "Interactive Histogram of Fat Content",
         xaxis = list(title = "Fat Content (%)"),
         yaxis = list(title = "Count"))
```
```{r}
plot_ly(cheeses_clean, x = ~type, y = ~fat_content, type = "box", color = ~type) %>%
  layout(title = "Fat Content by Cheese Type",
         xaxis = list(title = "Cheese Type"),
         yaxis = list(title = "Fat Content (%)"))
```

```{r}
plot_ly(cheeses_clean, x = ~fat_content, y = ~calcium_content, type = 'scatter', mode = 'markers',
        text = ~paste("Cheese:", cheese, "<br>Milk Type:", milk), color = ~milk) %>%
  layout(title = "Fat vs Calcium Content",
         xaxis = list(title = "Fat Content (%)"),
         yaxis = list(title = "Calcium Content (mg)"))
```

```{r}
region_counts <- cheeses_clean %>%
  count(region, type) %>%
  na.omit()

plot_ly(region_counts, x = ~region, y = ~type, z = ~n, type = "heatmap", colorscale = "Viridis") %>%
  layout(title = "Cheese Type by Region",
         xaxis = list(title = "Region", tickangle = 45),
         yaxis = list(title = "Cheese Type"))
```
```{r}
library(treemapify)

cheese_family_counts <- cheeses_clean %>%
  count(family, sort = TRUE) %>%
  na.omit()

plot_ly(cheese_family_counts, type = 'treemap', 
        labels = ~family, parents = NA, values = ~n,
        textinfo = "label+value+percent entry",
        marker = list(colors = c("#8dd3c7", "#ffffb3", "#bebada", "#fb8072"))) %>%
  layout(title = "Cheese Family Diversity")
```

```{r}
library(leaflet)
library(dplyr)
library(maps)

# Count cheeses by country
cheese_country <- cheeses_clean %>%
  count(country) %>%
  na.omit()

# Get map data with latitude and longitude
world_coords <- map_data("world") %>%
  group_by(region) %>%
  summarize(lat = mean(lat), long = mean(long))

# Join coordinates with cheese_country data
cheese_country_coords <- cheese_country %>%
  left_join(world_coords, by = c("country" = "region")) %>%
  na.omit()  # Remove rows where lat/long couldn't be matched

# Define a color palette based on the number of cheeses
pal <- colorNumeric(palette = "Blues", domain = cheese_country_coords$n)

# Create an interactive map
leaflet(data = cheese_country_coords) %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~long, lat = ~lat, # Use latitude and longitude
    radius = ~n / 10, 
    popup = ~paste(country, "<br>Number of Cheeses:", n),
    color = ~pal(n), fill = TRUE, fillOpacity = 0.7
  ) %>%
  addLegend(
    pal = pal,
    values = ~n,
    title = "Number of Cheeses",
    opacity = 1
  )
```
```{r}
library(tidytext)
library(wordcloud2)

flavor_words <- cheeses_clean %>%
  filter(!is.na(flavor)) %>%
  unnest_tokens(word, flavor) %>%
  count(word, sort = TRUE)

wordcloud2(flavor_words, size = 0.7, color = "random-dark")
```


```{r}
top_producers <- cheeses_clean %>%
  count(producers, sort = TRUE) %>%
  head(15)

plot_ly(top_producers, x = ~n, y = ~reorder(producers, n), type = "bar", orientation = "h") %>%
  layout(title = "Top 15 Cheese Producers",
         xaxis = list(title = "Number of Cheeses"),
         yaxis = list(title = "Producers"))
```


```{r}
plot_ly(cheeses_clean, x = ~year, type = "histogram") %>%
  layout(title = "Cheese Origin Over Time",
         xaxis = list(title = "Year"),
         yaxis = list(title = "Number of Cheeses"))
```

```{r}
library(networkD3)

milk_to_type <- cheeses_clean %>%
  count(milk, type) %>%
  na.omit()

nodes <- data.frame(name = unique(c(milk_to_type$milk, milk_to_type$type)))

milk_to_type$source <- match(milk_to_type$milk, nodes$name) - 1
milk_to_type$target <- match(milk_to_type$type, nodes$name) - 1

sankeyNetwork(Links = milk_to_type, Nodes = nodes,
              Source = "source", Target = "target", Value = "n",
              NodeID = "name", fontSize = 12, nodeWidth = 30)
```
```{r}
# Load required libraries
library(dplyr)
library(ggcorrplot)
library(corrplot)

# Step 1: Handle Missing Values and Select Numeric Columns
encoded_data <- cheeses_clean %>%
  mutate(across(where(is.character), as.factor)) %>% # Convert characters to factors
  mutate(across(where(is.factor), as.numeric)) %>%   # Convert factors to numeric
  select(where(is.numeric))                          # Select only numeric columns

# Check if numeric columns have missing values and handle them
encoded_data <- encoded_data %>%
  filter(rowSums(is.na(.)) < ncol(.))  # Drop rows where all values are NA

# Step 2: Compute the Correlation Matrix
if (ncol(encoded_data) > 1) {  # Ensure there are multiple columns for correlation
  correlation_matrix_full <- cor(encoded_data, use = "pairwise.complete.obs")
  
  # Step 3: Visualize the Correlation Matrix
  
  # Using ggcorrplot
  ggcorrplot(correlation_matrix_full, 
             method = "circle", 
             type = "lower", 
             lab = TRUE, 
             lab_size = 3, 
             title = "Correlation Matrix with Encoded Features",
             colors = c("red", "white", "blue"))
  
  # Using corrplot (alternative visualization)
  corrplot(correlation_matrix_full, 
           method = "color", 
           type = "lower", 
           addCoef.col = "black", 
           tl.col = "black", 
           tl.srt = 45, 
           diag = FALSE)
} else {
  message("Not enough numeric columns with complete data to compute correlations.")
}
```

```{r}
library(vcd)
```

```{r}
library(magrittr)
# Ensure the variables are factors
cheeses_clean <- cheeses_clean %>%
  mutate(milk = as.factor(milk),
         type = as.factor(type))
```



```{r}
library(plotly)

# Encode categorical variables into numeric values for the plot
cheeses_clean_encoded <- cheeses_clean %>%
  mutate(milk = as.numeric(as.factor(milk)),
         type = as.numeric(as.factor(type)))

# Create a parallel coordinate plot
plot_ly(data = cheeses_clean_encoded, type = 'parcoords',
        line = list(color = ~fat_content, colorscale = "Viridis"),
        dimensions = list(
          list(label = "Fat Content", values = ~fat_content),
          list(label = "Calcium Content", values = ~calcium_content),
          list(label = "Milk", values = ~milk),
          list(label = "Type", values = ~type)
        )) %>%
  layout(title = "Parallel Coordinates Plot for Multivariate Analysis")
```

```{r}
library(ggfortify)

# Prepare numeric data for PCA
numeric_data <- cheeses_clean %>%
  select(where(is.numeric)) %>%
  na.omit()

# Perform PCA
pca <- prcomp(numeric_data, scale. = TRUE)

# Plot PCA clustering
autoplot(pca, data = cheeses_clean, colour = 'type', label = TRUE, label.size = 3) +
  labs(title = "PCA Clustering of Cheeses",
       x = "Principal Component 1",
       y = "Principal Component 2") +
  theme_minimal()
```

```{r}
library(interactions)

# Example interaction plot
interaction.plot(cheeses_clean$milk, cheeses_clean$type, cheeses_clean$fat_content,
                 col = rainbow(4), legend = TRUE,
                 xlab = "Milk Type", ylab = "Fat Content",
                 main = "Interaction Between Milk and Cheese Type")
```
```{r}
library(leaflet)
world_coords <- map_data("world") %>% group_by(region) %>% summarize(lat = mean(lat), long = mean(long))
cheese_coords <- cheeses_clean %>% count(country) %>% left_join(world_coords, by = c("country" = "region"))
leaflet(data = cheese_coords) %>%
  addTiles() %>%
  addCircleMarkers(lng = ~long, lat = ~lat, radius = ~n / 10,
                   popup = ~paste(country, "<br>Number of Cheeses:", n),
                   color = "blue", fill = TRUE, fillOpacity = 0.7)
```

```{r}
library(treemapify)
cheese_tree <- cheeses_clean %>% count(family, type, sort = TRUE) %>% na.omit()
ggplot(cheese_tree, aes(area = n, fill = family, label = type)) +
  geom_treemap() +
  geom_treemap_text(color = "white", place = "center", grow = TRUE) +
  labs(title = "Cheese Families and Their Types", fill = "Family") +
  theme_minimal()
```

