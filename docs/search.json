[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cheese Chronicles: Exploring the Intersection of Sensory Qualities and Consumer Perception",
    "section": "",
    "text": "1 Introduction\nThis project dives into the fascinating world of cheese, analyzing its various characteristics and exploring how these factors influence ratings and preferences. Cheese, a beloved food worldwide, offers endless diversity in taste, texture, and production. Through this analysis, we aim to uncover what makes certain cheeses stand out and achieve higher ratings, while others lag behind. By identifying patterns and trends in the dataset, we hope to better understand the subtle dynamics of cheese appreciation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#background",
    "href": "index.html#background",
    "title": "Cheese Chronicles: Exploring the Intersection of Sensory Qualities and Consumer Perception",
    "section": "1.1 BACKGROUND",
    "text": "1.1 BACKGROUND\nCheese ratings often reflect both objective factors (like fat content, moisture, or production techniques) and subjective ones (like consumer taste and cultural preferences). For instance, cheeses made using traditional or artisanal methods might score higher due to their unique flavors and quality, while mass-produced cheeses may be perceived as more generic. Similarly, regional variations, such as the strong flavors of French cheeses or the milder profiles of American cheeses, may significantly influence consumer perception. Understanding these nuances can provide valuable insights for producers and consumers alike.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#objectives",
    "href": "index.html#objectives",
    "title": "Cheese Chronicles: Exploring the Intersection of Sensory Qualities and Consumer Perception",
    "section": "1.2 OBJECTIVES",
    "text": "1.2 OBJECTIVES\nThrough this project, we seek to answer the following questions: 1. What makes certain cheeses consistently achieve higher ratings compared to others? 2. How do physical and sensory attributes such as fat content, moisture levels, and texture influence these ratings? 3. Is there a connection between a cheese’s geographical origin and its rating? 4. What patterns emerge from analyzing sensory characteristics in relation to consumer preferences?\nBy tackling these questions, we hope to uncover the stories behind the numbers and paint a clearer picture of what truly defines a “great” cheese.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#methodology",
    "href": "index.html#methodology",
    "title": "Cheese Chronicles: Exploring the Intersection of Sensory Qualities and Consumer Perception",
    "section": "1.3 METHODOLOGY",
    "text": "1.3 METHODOLOGY\nTo meet our objectives, the analysis will involve: 1. A detailed exploration of the dataset to understand the structure, identify trends, and handle missing data appropriately. 2. The use of visual tools such as scatter plots, histograms, and box plots to illustrate relationships between different variables like fat content, moisture, and ratings. 3. Investigating correlations and patterns through statistical analyses and predictive models. 4. Comparing and contrasting cheeses based on type (e.g., goat, cow, or sheep milk) and origin to observe similarities and differences.\nBy following this structured approach, we aim to reveal meaningful insights that connect data patterns to real-world preferences.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "index.html#expected-outcomes",
    "href": "index.html#expected-outcomes",
    "title": "Cheese Chronicles: Exploring the Intersection of Sensory Qualities and Consumer Perception",
    "section": "1.4 EXPECTED OUTCOMES",
    "text": "1.4 EXPECTED OUTCOMES\nAt the conclusion of this project, we aim to deliver: 1. A comprehensive understanding of the key attributes that contribute to higher cheese ratings. 2. Insights into how consumer preferences align with specific sensory and physical characteristics. 3. Clear visualizations that bring the findings to life and provide a narrative about the factors driving cheese ratings.\nThese outcomes will not only enhance our understanding of the dataset but also offer a practical perspective on how cheese producers can better cater to their target markets.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "2  Data",
    "section": "",
    "text": "2.1 Technical Description\nThe dataset utilized for this project is sourced from cheese.com as part of the TidyTuesday initiative for the week of June 4, 2024. It comprises information on 248 different cheeses from around the world. The primary focus is to explore the relationship between fat content and various characteristics of cheeses, such as type, texture, flavor, and aroma.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#technical-description",
    "href": "data.html#technical-description",
    "title": "2  Data",
    "section": "",
    "text": "2.1.1 Data Source:\nThe dataset used for this project is sourced from cheese.com, curated as part of the TidyTuesday project for June 4, 2024.\nTidyTuesday is a weekly data project aimed at helping the R community practice their data wrangling, visualization, and analysis skills. The cheese dataset contains information on various types of cheeses worldwide, including attributes such as fat content, texture, flavor, aroma, and production details. The dataset encourages exploration of relationships between these characteristics.\n\n\n2.1.2 Variables Included:\n\ncheese: Name of the cheese.\nurl: URL to the cheese’s description on cheese.com.\nmilk: Type of milk used (e.g., cow, goat, sheep).\ncountry: Country or countries of origin.\nregion: Specific region within the country of origin.\nfamily: Family classification of the cheese.\ntype: Broad type categories describing the cheese.\nfat_content: Fat content percentage.\ncalcium_content: Calcium content (when available).\ntexture: Description of the cheese’s texture.\nrind: Type of rind used.\ncolor: Color description.\nflavor: Characteristics of taste.\naroma: Characteristics of smell.\nvegetarian: Indicates if the cheese is vegetarian.\nvegan: Indicates if the cheese is vegan.\nsynonyms: Alternative names for the cheese.\nalt_spellings: Alternative spellings of the cheese’s name.\nproducers: Known producers of the cheese.\n\nThis dataset provides a rich foundation for exploratory data analysis, enabling the investigation of various attributes and their interrelationships within the cheese domain.\n\n\n2.1.3 Installing packages\n\n\nCode\n# Install necessary packages\nrequired_packages &lt;- c(\"tidyverse\", \"tidytuesdayR\", \"naniar\", \"here\", \"fs\", \"rvest\", \"polite\", \"glue\", \"kableExtra\")\ninstalled_packages &lt;- rownames(installed.packages())\n\n# Load libraries\nlibrary(tidyverse)\nlibrary(tidytuesdayR)\nlibrary(naniar) # For missing value analysis\nlibrary(here)\nlibrary(fs)\nlibrary(rvest)\nlibrary(polite)\nlibrary(glue)\nlibrary(kableExtra) # For enhanced table styling\n\n\n\n\n2.1.4 Loading and Cleaning the Data\n\n\nCode\ntuesdata &lt;- tidytuesdayR::tt_load('2024-06-04')\n\n# Extract the cheeses dataset\ncheeses &lt;- tuesdata$cheeses\n\n# Save the cheeses dataset to a CSV file\nwrite.csv(cheeses, \"cheeses_dataset.csv\", row.names = FALSE)\n\n# Confirm the file has been saved\ncat(\"Dataset saved as 'cheeses_dataset.csv'\")\n\n\nDataset saved as 'cheeses_dataset.csv'\n\n\nCode\n# Display the first few rows\nhead(cheeses)\n\n\n# A tibble: 6 × 19\n  cheese     url   milk  country region family type  fat_content calcium_content\n  &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;          \n1 Aarewasser http… cow   Switze… &lt;NA&gt;   &lt;NA&gt;   semi… &lt;NA&gt;        &lt;NA&gt;           \n2 Abbaye de… http… sheep France  Pays … &lt;NA&gt;   semi… &lt;NA&gt;        &lt;NA&gt;           \n3 Abbaye de… http… cow   France  &lt;NA&gt;   &lt;NA&gt;   semi… 40-46%      &lt;NA&gt;           \n4 Abbaye de… http… cow   France  Burgu… &lt;NA&gt;   semi… &lt;NA&gt;        &lt;NA&gt;           \n5 Abbaye de… http… cow   France  Savoie &lt;NA&gt;   soft… &lt;NA&gt;        &lt;NA&gt;           \n6 Abbaye de… http… cow   France  provi… &lt;NA&gt;   semi… &lt;NA&gt;        &lt;NA&gt;           \n# ℹ 10 more variables: texture &lt;chr&gt;, rind &lt;chr&gt;, color &lt;chr&gt;, flavor &lt;chr&gt;,\n#   aroma &lt;chr&gt;, vegetarian &lt;lgl&gt;, vegan &lt;lgl&gt;, synonyms &lt;chr&gt;,\n#   alt_spellings &lt;chr&gt;, producers &lt;chr&gt;\n\n\n\n\n2.1.5 Cleaning and transforming the data\n\n\nCode\n# Cleaning and transforming the data\n\ncheeses &lt;- cheeses %&gt;%\n  mutate(\n    fat_content = str_extract(fat_content, \"\\\\d+\\\\.*\\\\d*\") %&gt;% as.numeric(),\n    calcium_content = str_extract(calcium_content, \"\\\\d+\\\\.*\\\\d*\") %&gt;% as.numeric(),\n    vegetarian = case_when(\n      vegetarian == \"yes\" ~ TRUE,\n      vegetarian == \"no\" ~ FALSE,\n      TRUE ~ NA\n    ),\n    vegan = case_when(\n      vegan == \"yes\" ~ TRUE,\n      vegan == \"no\" ~ FALSE,\n      TRUE ~ NA\n    )\n  )\n\n# Check the transformation\nglimpse(cheeses)\n\n\nRows: 1,187\nColumns: 19\n$ cheese          &lt;chr&gt; \"Aarewasser\", \"Abbaye de Belloc\", \"Abbaye de Belval\", …\n$ url             &lt;chr&gt; \"https://www.cheese.com/aarewasser/\", \"https://www.che…\n$ milk            &lt;chr&gt; \"cow\", \"sheep\", \"cow\", \"cow\", \"cow\", \"cow\", \"cow\", \"co…\n$ country         &lt;chr&gt; \"Switzerland\", \"France\", \"France\", \"France\", \"France\",…\n$ region          &lt;chr&gt; NA, \"Pays Basque\", NA, \"Burgundy\", \"Savoie\", \"province…\n$ family          &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, \"Cheddar\", NA, NA, NA, NA,…\n$ type            &lt;chr&gt; \"semi-soft\", \"semi-hard, artisan\", \"semi-hard\", \"semi-…\n$ fat_content     &lt;dbl&gt; NA, NA, 40, NA, NA, NA, 50, NA, 45, NA, NA, NA, NA, 52…\n$ calcium_content &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ texture         &lt;chr&gt; \"buttery\", \"creamy, dense, firm\", \"elastic\", \"creamy, …\n$ rind            &lt;chr&gt; \"washed\", \"natural\", \"washed\", \"washed\", \"washed\", \"wa…\n$ color           &lt;chr&gt; \"yellow\", \"yellow\", \"ivory\", \"white\", \"white\", \"pale y…\n$ flavor          &lt;chr&gt; \"sweet\", \"burnt caramel\", NA, \"acidic, milky, smooth\",…\n$ aroma           &lt;chr&gt; \"buttery\", \"lanoline\", \"aromatic\", \"barnyardy, earthy\"…\n$ vegetarian      &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ vegan           &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ synonyms        &lt;chr&gt; NA, \"Abbaye Notre-Dame de Belloc\", NA, NA, NA, NA, NA,…\n$ alt_spellings   &lt;chr&gt; NA, NA, NA, NA, \"Tamié, Trappiste de Tamie, Abbey of T…\n$ producers       &lt;chr&gt; \"Jumi\", NA, NA, NA, NA, \"Abbaye Cistercienne NOTRE-DAM…\n\n\nThe code is used to clean and adjust the cheeses dataset by converting the fat_content and calcium_content columns into numeric values, extracting only the relevant digits. It also changes the vegetarian and vegan columns from “yes”/“no” responses to Boolean values (TRUE/FALSE), handling any other responses as NA. After these changes, the glimpse() function is used to check the updated dataset.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#missing-value-analysis",
    "href": "data.html#missing-value-analysis",
    "title": "2  Data",
    "section": "2.2 Missing Value Analysis",
    "text": "2.2 Missing Value Analysis\nUnderstanding the presence and patterns of missing data is crucial for ensuring the integrity of the analysis. Below is a summary and visualization of missing values in the dataset.\n\n2.2.1 Visualization of Missing Data\nThe following plot illustrates the pattern of missing values across different variables, providing a visual overview of data completeness.\n\n\nCode\n# Plot missing data with improvements\nvis_miss(cheeses) + \n  theme_minimal() +\n  labs(title = \"Missing Data Pattern in Cheeses Dataset\",\n       x = \"Variables\",\n       y = \"Observations\") +\n  theme(\n    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),  # Rotate labels vertically\n    plot.title = element_text(size = 16, face = \"bold\", hjust = 0.5)  # Center and bold title\n  )\n\n\n\n\n\n\n\n\n\nThis visualization provides an overview of the missing data patterns in the Cheeses dataset. Each variable is displayed along the x-axis, and the presence or absence of data for each observation is represented in the y-axis. • The black regions represent missing values, while the gray regions indicate available data. • Variables like vegetarian, vegan, and alt_spellings show significant amounts of missing data, with up to 100% missing for some variables. • On the other hand, variables like cheese and url have no missing values, ensuring reliability in these fields for analysis.\nThis visualization highlights areas where imputation or exclusion strategies need to be applied to handle missing data effectively before proceeding with further analysis.\n\n\n2.2.2 Overall Missing Data Pie Chart\nTo provide an additional perspective on the missing data, here’s a pie chart that visualizes the overall proportion of missing versus present data in the dataset.\n\n\nCode\n# Calculate total missing and present values\ntotal_missing &lt;- sum(is.na(cheeses))\ntotal_present &lt;- sum(!is.na(cheeses))\n\n# Create a data frame for the pie chart\nmissing_data_pie &lt;- data.frame(\n  Status = c(\"Missing\", \"Present\"),\n  Count = c(total_missing, total_present)\n)\n\n# Calculate percentages\nmissing_data_pie &lt;- missing_data_pie %&gt;%\n  mutate(Percentage = round(Count / sum(Count) * 100, 1))\n\n# Plot the pie chart with percentages\nggplot(missing_data_pie, aes(x = \"\", y = Count, fill = Status)) +\n  geom_bar(stat = \"identity\", width = 1, color = \"white\") +\n  coord_polar(theta = \"y\") +\n  geom_text(aes(label = paste0(Percentage, \"%\")), \n            position = position_stack(vjust = 0.5), size = 5) +\n  labs(title = \"Overall Missing vs Present Data\") +\n  theme_void() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\", hjust = 0.5),\n    legend.title = element_blank(),\n    legend.position = \"right\"\n  )\n\n\n\n\n\n\n\n\n\nThe pie chart above provides a clear summary of the overall missing versus present data in the dataset. This visualization complements the heatmap by offering a high-level view of data completeness, aiding in quickly assessing the extent of missing data.\n\n\n2.2.3 Handling Missing Values\nTo address the missing data, we employed the following strategies:\n\nRemoval of Incomplete Cases: Rows with missing fat_content were excluded to ensure data integrity.\nImputation: Missing values in calcium_content were imputed using the median value, preserving the central tendency of the data.\n\nThese steps help mitigate the impact of missing data on our analysis, ensuring more reliable results.\n\n\nCode\n# Summary of missing values before cleaning\nmissing_summary_before &lt;- cheeses %&gt;%\n  summarise_all(~ sum(is.na(.))) %&gt;%\n  pivot_longer(cols = everything(), names_to = \"Variable\", values_to = \"Missing_Count\") %&gt;%\n  arrange(desc(Missing_Count))\n\n# Removing rows with missing fat_content\ncheeses_clean &lt;- cheeses %&gt;%\n  filter(!is.na(fat_content))\n\n# Imputing missing calcium_content with the median value\ncheeses_clean &lt;- cheeses_clean %&gt;%\n  mutate(calcium_content = if_else(is.na(calcium_content),\n                                   median(calcium_content, na.rm = TRUE),\n                                   calcium_content))\n\n# Summary of missing values after cleaning\nmissing_summary_after &lt;- cheeses_clean %&gt;%\n  summarise_all(~ sum(is.na(.))) %&gt;%\n  pivot_longer(cols = everything(), names_to = \"Variable\", values_to = \"Missing_Count\") %&gt;%\n  arrange(desc(Missing_Count))\n\n# Display the summary tables before and after cleaning\nknitr::kable(missing_summary_before, caption = \"Missing Values Before Cleaning\") %&gt;%\n  kableExtra::kable_styling(full_width = FALSE, position = \"left\") %&gt;%\n  kableExtra::add_header_above(c(\" \" = 1, \"Missing Values\" = 1))\n\n\n\nMissing Values Before Cleaning\n\n\n\n\n\n\n\n\nMissing Values\n\n\n\nVariable\nMissing_Count\n\n\n\n\nvegetarian\n1187\n\n\nvegan\n1187\n\n\ncalcium_content\n1162\n\n\nalt_spellings\n1078\n\n\nfat_content\n939\n\n\nsynonyms\n893\n\n\nfamily\n698\n\n\nproducers\n400\n\n\nregion\n332\n\n\naroma\n258\n\n\nrind\n242\n\n\ncolor\n142\n\n\nflavor\n98\n\n\ntexture\n58\n\n\nmilk\n36\n\n\ntype\n13\n\n\ncountry\n11\n\n\ncheese\n0\n\n\nurl\n0\n\n\n\n\n\n\n\nCode\nknitr::kable(missing_summary_after, caption = \"Missing Values After Cleaning\") %&gt;%\n  kableExtra::kable_styling(full_width = FALSE, position = \"left\") %&gt;%\n  kableExtra::add_header_above(c(\" \" = 1, \"Missing Values\" = 1))\n\n\n\nMissing Values After Cleaning\n\n\n\n\n\n\n\n\nMissing Values\n\n\n\nVariable\nMissing_Count\n\n\n\n\nvegetarian\n248\n\n\nvegan\n248\n\n\nalt_spellings\n206\n\n\nsynonyms\n172\n\n\nfamily\n165\n\n\nproducers\n100\n\n\naroma\n61\n\n\nregion\n52\n\n\nrind\n40\n\n\ncolor\n25\n\n\ntexture\n17\n\n\nflavor\n12\n\n\nmilk\n6\n\n\ncountry\n1\n\n\ntype\n1\n\n\ncheese\n0\n\n\nurl\n0\n\n\nfat_content\n0\n\n\ncalcium_content\n0\n\n\n\n\n\n\n\nThe code provided effectively handles missing values in the dataset by first summarizing the missing data before any cleaning is done. It identifies the columns with the most missing values, such as vegetarian and vegan, which initially had 1187 missing entries. Next, the code removes rows with missing fat_content values and imputes missing calcium_content values with the median value, ensuring the dataset remains complete without losing important data. After cleaning, the missing values for key variables are significantly reduced, demonstrating the success of the cleaning process. This approach makes the dataset more reliable for analysis, ensuring that missing data doesn’t skew the results or lead to biased conclusions.\n\n\nCode\ncheese_country_counts &lt;- cheeses_clean %&gt;%\n  count(country, sort = TRUE) %&gt;%\n  head(15)\n\nggplot(cheese_country_counts, aes(x = reorder(country, n), y = n)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  coord_flip() +\n  labs(title = \"Top 15 Countries Producing Cheese\",\n       x = \"Country\",\n       y = \"Number of Cheeses\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\nCode\ntop_countries &lt;- cheese_country_counts$country\n\nggplot(cheeses_clean %&gt;% filter(country %in% top_countries), \n       aes(x = country, y = fat_content, fill = country)) +\n  geom_boxplot() +\n  coord_flip() +\n  labs(title = \"Fat Content Distribution Across Top Cheese-Producing Countries\",\n       x = \"Country\",\n       y = \"Fat Content (%)\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\nCode\nfamily_counts &lt;- cheeses_clean %&gt;%\n  count(family, sort = TRUE) %&gt;%\n  filter(!is.na(family))\n\nggplot(family_counts, aes(x = reorder(family, n), y = n, fill = family)) +\n  geom_bar(stat = \"identity\") +\n  coord_flip() +\n  labs(title = \"Cheese Family Diversity\",\n       x = \"Family\",\n       y = \"Number of Cheeses\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\nCode\nggplot(cheeses_clean, aes(x = fat_content)) +\n  geom_histogram(binwidth = 5, fill = \"steelblue\", color = \"white\", alpha = 0.8) +\n  labs(title = \"Distribution of Fat Content\",\n       x = \"Fat Content (%)\",\n       y = \"Count\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\nCode\nggplot(cheeses_clean, aes(x = type, y = fat_content, fill = type)) +\n  geom_boxplot(outlier.color = \"red\", alpha = 0.7) +\n  coord_flip() +\n  labs(title = \"Fat Content by Cheese Type\",\n       x = \"Cheese Type\",\n       y = \"Fat Content (%)\") +\n  theme_minimal() +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nlibrary(tidytext)\nlibrary(wordcloud2)\n\ntexture_words &lt;- cheeses_clean %&gt;%\n  filter(!is.na(texture)) %&gt;%\n  unnest_tokens(word, texture) %&gt;%\n  count(word, sort = TRUE)\n\nwordcloud2(texture_words, size = 0.7)\n\n\n\n\n\n\n\n\nCode\nlibrary(treemapify)\n\ncheese_diversity &lt;- cheeses_clean %&gt;%\n  count(country, family, sort = TRUE)\n\nggplot(cheese_diversity, aes(area = n, fill = family, label = country)) +\n  geom_treemap() +\n  geom_treemap_text(color = \"white\", place = \"center\", grow = TRUE) +\n  labs(title = \"Cheese Production Diversity by Country\",\n       fill = \"Family\") +\n  theme_minimal()\n\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_treemap_text()`).\n\n\n\n\n\n\n\n\n\n\n\nCode\nlibrary(plotly)\n\n\n\nAttaching package: 'plotly'\n\n\nThe following object is masked from 'package:ggplot2':\n\n    last_plot\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\nThe following object is masked from 'package:graphics':\n\n    layout\n\n\nCode\nplot_ly(cheeses_clean, x = ~fat_content, type = \"histogram\") %&gt;%\n  layout(title = \"Interactive Histogram of Fat Content\",\n         xaxis = list(title = \"Fat Content (%)\"),\n         yaxis = list(title = \"Count\"))\n\n\n\n\n\n\n\n\nCode\nplot_ly(cheeses_clean, x = ~type, y = ~fat_content, type = \"box\", color = ~type) %&gt;%\n  layout(title = \"Fat Content by Cheese Type\",\n         xaxis = list(title = \"Cheese Type\"),\n         yaxis = list(title = \"Fat Content (%)\"))\n\n\nWarning: Ignoring 1 observations\n\n\nWarning in RColorBrewer::brewer.pal(N, \"Set2\"): n too large, allowed maximum for palette Set2 is 8\nReturning the palette you asked for with that many colors\nWarning in RColorBrewer::brewer.pal(N, \"Set2\"): n too large, allowed maximum for palette Set2 is 8\nReturning the palette you asked for with that many colors\n\n\n\n\n\n\n\n\nCode\nplot_ly(cheeses_clean, x = ~fat_content, y = ~calcium_content, type = 'scatter', mode = 'markers',\n        text = ~paste(\"Cheese:\", cheese, \"&lt;br&gt;Milk Type:\", milk), color = ~milk) %&gt;%\n  layout(title = \"Fat vs Calcium Content\",\n         xaxis = list(title = \"Fat Content (%)\"),\n         yaxis = list(title = \"Calcium Content (mg)\"))\n\n\nWarning in RColorBrewer::brewer.pal(N, \"Set2\"): n too large, allowed maximum for palette Set2 is 8\nReturning the palette you asked for with that many colors\nWarning in RColorBrewer::brewer.pal(N, \"Set2\"): n too large, allowed maximum for palette Set2 is 8\nReturning the palette you asked for with that many colors\n\n\n\n\n\n\n\n\nCode\nregion_counts &lt;- cheeses_clean %&gt;%\n  count(region, type) %&gt;%\n  na.omit()\n\nplot_ly(region_counts, x = ~region, y = ~type, z = ~n, type = \"heatmap\", colorscale = \"Viridis\") %&gt;%\n  layout(title = \"Cheese Type by Region\",\n         xaxis = list(title = \"Region\", tickangle = 45),\n         yaxis = list(title = \"Cheese Type\"))\n\n\n\n\n\n\n\n\nCode\nlibrary(treemapify)\n\ncheese_family_counts &lt;- cheeses_clean %&gt;%\n  count(family, sort = TRUE) %&gt;%\n  na.omit()\n\nplot_ly(cheese_family_counts, type = 'treemap', \n        labels = ~family, parents = NA, values = ~n,\n        textinfo = \"label+value+percent entry\",\n        marker = list(colors = c(\"#8dd3c7\", \"#ffffb3\", \"#bebada\", \"#fb8072\"))) %&gt;%\n  layout(title = \"Cheese Family Diversity\")\n\n\n\n\n\n\n\n\nCode\nlibrary(leaflet)\nlibrary(dplyr)\nlibrary(maps)\n\n\n\nAttaching package: 'maps'\n\n\nThe following object is masked from 'package:purrr':\n\n    map\n\n\nCode\n# Count cheeses by country\ncheese_country &lt;- cheeses_clean %&gt;%\n  count(country) %&gt;%\n  na.omit()\n\n# Get map data with latitude and longitude\nworld_coords &lt;- map_data(\"world\") %&gt;%\n  group_by(region) %&gt;%\n  summarize(lat = mean(lat), long = mean(long))\n\n# Join coordinates with cheese_country data\ncheese_country_coords &lt;- cheese_country %&gt;%\n  left_join(world_coords, by = c(\"country\" = \"region\")) %&gt;%\n  na.omit()  # Remove rows where lat/long couldn't be matched\n\n# Define a color palette based on the number of cheeses\npal &lt;- colorNumeric(palette = \"Blues\", domain = cheese_country_coords$n)\n\n# Create an interactive map\nleaflet(data = cheese_country_coords) %&gt;%\n  addTiles() %&gt;%\n  addCircleMarkers(\n    lng = ~long, lat = ~lat, # Use latitude and longitude\n    radius = ~n / 10, \n    popup = ~paste(country, \"&lt;br&gt;Number of Cheeses:\", n),\n    color = ~pal(n), fill = TRUE, fillOpacity = 0.7\n  ) %&gt;%\n  addLegend(\n    pal = pal,\n    values = ~n,\n    title = \"Number of Cheeses\",\n    opacity = 1\n  )\n\n\n\n\n\n\n\n\nCode\nlibrary(tidytext)\nlibrary(wordcloud2)\n\nflavor_words &lt;- cheeses_clean %&gt;%\n  filter(!is.na(flavor)) %&gt;%\n  unnest_tokens(word, flavor) %&gt;%\n  count(word, sort = TRUE)\n\nwordcloud2(flavor_words, size = 0.7, color = \"random-dark\")\n\n\n\n\n\n\n\n\nCode\ntop_producers &lt;- cheeses_clean %&gt;%\n  count(producers, sort = TRUE) %&gt;%\n  head(15)\n\nplot_ly(top_producers, x = ~n, y = ~reorder(producers, n), type = \"bar\", orientation = \"h\") %&gt;%\n  layout(title = \"Top 15 Cheese Producers\",\n         xaxis = list(title = \"Number of Cheeses\"),\n         yaxis = list(title = \"Producers\"))\n\n\nWarning: Ignoring 1 observations\n\n\n\n\n\n\n\n\nCode\nplot_ly(cheeses_clean, x = ~year, type = \"histogram\") %&gt;%\n  layout(title = \"Cheese Origin Over Time\",\n         xaxis = list(title = \"Year\"),\n         yaxis = list(title = \"Number of Cheeses\"))\n\n\n\n\n\n\n\n\nCode\nlibrary(networkD3)\n\n\n\nAttaching package: 'networkD3'\n\n\nThe following object is masked from 'package:leaflet':\n\n    JS\n\n\nCode\nmilk_to_type &lt;- cheeses_clean %&gt;%\n  count(milk, type) %&gt;%\n  na.omit()\n\nnodes &lt;- data.frame(name = unique(c(milk_to_type$milk, milk_to_type$type)))\n\nmilk_to_type$source &lt;- match(milk_to_type$milk, nodes$name) - 1\nmilk_to_type$target &lt;- match(milk_to_type$type, nodes$name) - 1\n\nsankeyNetwork(Links = milk_to_type, Nodes = nodes,\n              Source = \"source\", Target = \"target\", Value = \"n\",\n              NodeID = \"name\", fontSize = 12, nodeWidth = 30)\n\n\nLinks is a tbl_df. Converting to a plain data frame.\n\n\n\n\n\n\n\n\nCode\n# Load required libraries\nlibrary(dplyr)\nlibrary(ggcorrplot)\nlibrary(corrplot)\n\n\ncorrplot 0.95 loaded\n\n\nCode\n# Step 1: Handle Missing Values and Select Numeric Columns\nencoded_data &lt;- cheeses_clean %&gt;%\n  mutate(across(where(is.character), as.factor)) %&gt;% # Convert characters to factors\n  mutate(across(where(is.factor), as.numeric)) %&gt;%   # Convert factors to numeric\n  select(where(is.numeric))                          # Select only numeric columns\n\n# Check if numeric columns have missing values and handle them\nencoded_data &lt;- encoded_data %&gt;%\n  filter(rowSums(is.na(.)) &lt; ncol(.))  # Drop rows where all values are NA\n\n# Step 2: Compute the Correlation Matrix\nif (ncol(encoded_data) &gt; 1) {  # Ensure there are multiple columns for correlation\n  correlation_matrix_full &lt;- cor(encoded_data, use = \"pairwise.complete.obs\")\n  \n  # Step 3: Visualize the Correlation Matrix\n  \n  # Using ggcorrplot\n  ggcorrplot(correlation_matrix_full, \n             method = \"circle\", \n             type = \"lower\", \n             lab = TRUE, \n             lab_size = 3, \n             title = \"Correlation Matrix with Encoded Features\",\n             colors = c(\"red\", \"white\", \"blue\"))\n  \n  # Using corrplot (alternative visualization)\n  corrplot(correlation_matrix_full, \n           method = \"color\", \n           type = \"lower\", \n           addCoef.col = \"black\", \n           tl.col = \"black\", \n           tl.srt = 45, \n           diag = FALSE)\n} else {\n  message(\"Not enough numeric columns with complete data to compute correlations.\")\n}\n\n\n\n\n\n\n\n\n\n\n\nCode\nlibrary(vcd)\n\n\nLoading required package: grid\n\n\n\n\nCode\nlibrary(magrittr)\n\n\n\nAttaching package: 'magrittr'\n\n\nThe following object is masked from 'package:purrr':\n\n    set_names\n\n\nThe following object is masked from 'package:tidyr':\n\n    extract\n\n\nCode\n# Ensure the variables are factors\ncheeses_clean &lt;- cheeses_clean %&gt;%\n  mutate(milk = as.factor(milk),\n         type = as.factor(type))\n\n\n\n\nCode\nlibrary(plotly)\n\n# Encode categorical variables into numeric values for the plot\ncheeses_clean_encoded &lt;- cheeses_clean %&gt;%\n  mutate(milk = as.numeric(as.factor(milk)),\n         type = as.numeric(as.factor(type)))\n\n# Create a parallel coordinate plot\nplot_ly(data = cheeses_clean_encoded, type = 'parcoords',\n        line = list(color = ~fat_content, colorscale = \"Viridis\"),\n        dimensions = list(\n          list(label = \"Fat Content\", values = ~fat_content),\n          list(label = \"Calcium Content\", values = ~calcium_content),\n          list(label = \"Milk\", values = ~milk),\n          list(label = \"Type\", values = ~type)\n        )) %&gt;%\n  layout(title = \"Parallel Coordinates Plot for Multivariate Analysis\")\n\n\n\n\n\n\n\n\nCode\nlibrary(ggfortify)\n\n# Prepare numeric data for PCA\nnumeric_data &lt;- cheeses_clean %&gt;%\n  select(where(is.numeric)) %&gt;%\n  na.omit()\n\n# Perform PCA\npca &lt;- prcomp(numeric_data, scale. = TRUE)\n\n# Plot PCA clustering\nautoplot(pca, data = cheeses_clean, colour = 'type', label = TRUE, label.size = 3) +\n  labs(title = \"PCA Clustering of Cheeses\",\n       x = \"Principal Component 1\",\n       y = \"Principal Component 2\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\nCode\nlibrary(interactions)\n\n# Example interaction plot\ninteraction.plot(cheeses_clean$milk, cheeses_clean$type, cheeses_clean$fat_content,\n                 col = rainbow(4), legend = TRUE,\n                 xlab = \"Milk Type\", ylab = \"Fat Content\",\n                 main = \"Interaction Between Milk and Cheese Type\")\n\n\n\n\n\n\n\n\n\n\n\nCode\nlibrary(leaflet)\nworld_coords &lt;- map_data(\"world\") %&gt;% group_by(region) %&gt;% summarize(lat = mean(lat), long = mean(long))\ncheese_coords &lt;- cheeses_clean %&gt;% count(country) %&gt;% left_join(world_coords, by = c(\"country\" = \"region\"))\nleaflet(data = cheese_coords) %&gt;%\n  addTiles() %&gt;%\n  addCircleMarkers(lng = ~long, lat = ~lat, radius = ~n / 10,\n                   popup = ~paste(country, \"&lt;br&gt;Number of Cheeses:\", n),\n                   color = \"blue\", fill = TRUE, fillOpacity = 0.7)\n\n\nWarning in validateCoords(lng, lat, funcName): Data contains 21 rows with\neither missing or invalid lat/lon values and will be ignored\n\n\n\n\n\n\n\n\nCode\nlibrary(treemapify)\ncheese_tree &lt;- cheeses_clean %&gt;% count(family, type, sort = TRUE) %&gt;% na.omit()\nggplot(cheese_tree, aes(area = n, fill = family, label = type)) +\n  geom_treemap() +\n  geom_treemap_text(color = \"white\", place = \"center\", grow = TRUE) +\n  labs(title = \"Cheese Families and Their Types\", fill = \"Family\") +\n  theme_minimal()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  }
]